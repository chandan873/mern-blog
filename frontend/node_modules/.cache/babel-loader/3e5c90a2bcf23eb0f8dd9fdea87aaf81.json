{"ast":null,"code":"'use strict';\n\nimport stream from 'stream';\nimport utils from '../utils.js';\nconst kInternals = Symbol('internals');\n\nclass AxiosTransformStream extends stream.Transform {\n  constructor(options) {\n    options = utils.toFlatObject(options, {\n      maxRate: 0,\n      chunkSize: 64 * 1024,\n      minChunkSize: 100,\n      timeWindow: 500,\n      ticksRate: 2,\n      samplesCount: 15\n    }, null, (prop, source) => {\n      return !utils.isUndefined(source[prop]);\n    });\n    super({\n      readableHighWaterMark: options.chunkSize\n    });\n    const internals = this[kInternals] = {\n      timeWindow: options.timeWindow,\n      chunkSize: options.chunkSize,\n      maxRate: options.maxRate,\n      minChunkSize: options.minChunkSize,\n      bytesSeen: 0,\n      isCaptured: false,\n      notifiedBytesLoaded: 0,\n      ts: Date.now(),\n      bytes: 0,\n      onReadCallback: null\n    };\n    this.on('newListener', event => {\n      if (event === 'progress') {\n        if (!internals.isCaptured) {\n          internals.isCaptured = true;\n        }\n      }\n    });\n  }\n\n  _read(size) {\n    const internals = this[kInternals];\n\n    if (internals.onReadCallback) {\n      internals.onReadCallback();\n    }\n\n    return super._read(size);\n  }\n\n  _transform(chunk, encoding, callback) {\n    const internals = this[kInternals];\n    const maxRate = internals.maxRate;\n    const readableHighWaterMark = this.readableHighWaterMark;\n    const timeWindow = internals.timeWindow;\n    const divider = 1000 / timeWindow;\n    const bytesThreshold = maxRate / divider;\n    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;\n\n    const pushChunk = (_chunk, _callback) => {\n      const bytes = Buffer.byteLength(_chunk);\n      internals.bytesSeen += bytes;\n      internals.bytes += bytes;\n      internals.isCaptured && this.emit('progress', internals.bytesSeen);\n\n      if (this.push(_chunk)) {\n        process.nextTick(_callback);\n      } else {\n        internals.onReadCallback = () => {\n          internals.onReadCallback = null;\n          process.nextTick(_callback);\n        };\n      }\n    };\n\n    const transformChunk = (_chunk, _callback) => {\n      const chunkSize = Buffer.byteLength(_chunk);\n      let chunkRemainder = null;\n      let maxChunkSize = readableHighWaterMark;\n      let bytesLeft;\n      let passed = 0;\n\n      if (maxRate) {\n        const now = Date.now();\n\n        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {\n          internals.ts = now;\n          bytesLeft = bytesThreshold - internals.bytes;\n          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;\n          passed = 0;\n        }\n\n        bytesLeft = bytesThreshold - internals.bytes;\n      }\n\n      if (maxRate) {\n        if (bytesLeft <= 0) {\n          // next time window\n          return setTimeout(() => {\n            _callback(null, _chunk);\n          }, timeWindow - passed);\n        }\n\n        if (bytesLeft < maxChunkSize) {\n          maxChunkSize = bytesLeft;\n        }\n      }\n\n      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {\n        chunkRemainder = _chunk.subarray(maxChunkSize);\n        _chunk = _chunk.subarray(0, maxChunkSize);\n      }\n\n      pushChunk(_chunk, chunkRemainder ? () => {\n        process.nextTick(_callback, null, chunkRemainder);\n      } : _callback);\n    };\n\n    transformChunk(chunk, function transformNextChunk(err, _chunk) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (_chunk) {\n        transformChunk(_chunk, transformNextChunk);\n      } else {\n        callback(null);\n      }\n    });\n  }\n\n}\n\nexport default AxiosTransformStream;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/New folder/node_modules/axios/lib/helpers/AxiosTransformStream.js"],"names":["stream","utils","kInternals","Symbol","AxiosTransformStream","Transform","constructor","options","toFlatObject","maxRate","chunkSize","minChunkSize","timeWindow","ticksRate","samplesCount","prop","source","isUndefined","readableHighWaterMark","internals","bytesSeen","isCaptured","notifiedBytesLoaded","ts","Date","now","bytes","onReadCallback","on","event","_read","size","_transform","chunk","encoding","callback","divider","bytesThreshold","Math","max","pushChunk","_chunk","_callback","Buffer","byteLength","emit","push","process","nextTick","transformChunk","chunkRemainder","maxChunkSize","bytesLeft","passed","setTimeout","subarray","transformNextChunk","err"],"mappings":"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","sourcesContent":["'use strict';\n\nimport stream from 'stream';\nimport utils from '../utils.js';\n\nconst kInternals = Symbol('internals');\n\nclass AxiosTransformStream extends stream.Transform{\n  constructor(options) {\n    options = utils.toFlatObject(options, {\n      maxRate: 0,\n      chunkSize: 64 * 1024,\n      minChunkSize: 100,\n      timeWindow: 500,\n      ticksRate: 2,\n      samplesCount: 15\n    }, null, (prop, source) => {\n      return !utils.isUndefined(source[prop]);\n    });\n\n    super({\n      readableHighWaterMark: options.chunkSize\n    });\n\n    const internals = this[kInternals] = {\n      timeWindow: options.timeWindow,\n      chunkSize: options.chunkSize,\n      maxRate: options.maxRate,\n      minChunkSize: options.minChunkSize,\n      bytesSeen: 0,\n      isCaptured: false,\n      notifiedBytesLoaded: 0,\n      ts: Date.now(),\n      bytes: 0,\n      onReadCallback: null\n    };\n\n    this.on('newListener', event => {\n      if (event === 'progress') {\n        if (!internals.isCaptured) {\n          internals.isCaptured = true;\n        }\n      }\n    });\n  }\n\n  _read(size) {\n    const internals = this[kInternals];\n\n    if (internals.onReadCallback) {\n      internals.onReadCallback();\n    }\n\n    return super._read(size);\n  }\n\n  _transform(chunk, encoding, callback) {\n    const internals = this[kInternals];\n    const maxRate = internals.maxRate;\n\n    const readableHighWaterMark = this.readableHighWaterMark;\n\n    const timeWindow = internals.timeWindow;\n\n    const divider = 1000 / timeWindow;\n    const bytesThreshold = (maxRate / divider);\n    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;\n\n    const pushChunk = (_chunk, _callback) => {\n      const bytes = Buffer.byteLength(_chunk);\n      internals.bytesSeen += bytes;\n      internals.bytes += bytes;\n\n      internals.isCaptured && this.emit('progress', internals.bytesSeen);\n\n      if (this.push(_chunk)) {\n        process.nextTick(_callback);\n      } else {\n        internals.onReadCallback = () => {\n          internals.onReadCallback = null;\n          process.nextTick(_callback);\n        };\n      }\n    }\n\n    const transformChunk = (_chunk, _callback) => {\n      const chunkSize = Buffer.byteLength(_chunk);\n      let chunkRemainder = null;\n      let maxChunkSize = readableHighWaterMark;\n      let bytesLeft;\n      let passed = 0;\n\n      if (maxRate) {\n        const now = Date.now();\n\n        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {\n          internals.ts = now;\n          bytesLeft = bytesThreshold - internals.bytes;\n          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;\n          passed = 0;\n        }\n\n        bytesLeft = bytesThreshold - internals.bytes;\n      }\n\n      if (maxRate) {\n        if (bytesLeft <= 0) {\n          // next time window\n          return setTimeout(() => {\n            _callback(null, _chunk);\n          }, timeWindow - passed);\n        }\n\n        if (bytesLeft < maxChunkSize) {\n          maxChunkSize = bytesLeft;\n        }\n      }\n\n      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {\n        chunkRemainder = _chunk.subarray(maxChunkSize);\n        _chunk = _chunk.subarray(0, maxChunkSize);\n      }\n\n      pushChunk(_chunk, chunkRemainder ? () => {\n        process.nextTick(_callback, null, chunkRemainder);\n      } : _callback);\n    };\n\n    transformChunk(chunk, function transformNextChunk(err, _chunk) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (_chunk) {\n        transformChunk(_chunk, transformNextChunk);\n      } else {\n        callback(null);\n      }\n    });\n  }\n}\n\nexport default AxiosTransformStream;\n"]},"metadata":{},"sourceType":"module"}