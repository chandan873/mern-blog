{"ast":null,"code":"'use strict';\n\nimport utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport buildFullPath from '../core/buildFullPath.js';\nimport buildURL from './../helpers/buildURL.js';\nimport proxyFromEnv from 'proxy-from-env';\nimport http from 'http';\nimport https from 'https';\nimport util from 'util';\nimport followRedirects from 'follow-redirects';\nimport zlib from 'zlib';\nimport { VERSION } from '../env/data.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport platform from '../platform/index.js';\nimport fromDataURI from '../helpers/fromDataURI.js';\nimport stream from 'stream';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport AxiosTransformStream from '../helpers/AxiosTransformStream.js';\nimport { EventEmitter } from 'events';\nimport formDataToStream from \"../helpers/formDataToStream.js\";\nimport readBlob from \"../helpers/readBlob.js\";\nimport ZlibHeaderTransformStream from '../helpers/ZlibHeaderTransformStream.js';\nimport callbackify from \"../helpers/callbackify.js\";\nimport { progressEventReducer, progressEventDecorator, asyncDecorator } from \"../helpers/progressEventReducer.js\";\nconst zlibOptions = {\n  flush: zlib.constants.Z_SYNC_FLUSH,\n  finishFlush: zlib.constants.Z_SYNC_FLUSH\n};\nconst brotliOptions = {\n  flush: zlib.constants.BROTLI_OPERATION_FLUSH,\n  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH\n};\nconst isBrotliSupported = utils.isFunction(zlib.createBrotliDecompress);\nconst {\n  http: httpFollow,\n  https: httpsFollow\n} = followRedirects;\nconst isHttps = /https:?/;\nconst supportedProtocols = platform.protocols.map(protocol => {\n  return protocol + ':';\n});\n\nconst flushOnFinish = (stream, _ref) => {\n  let [throttled, flush] = _ref;\n  stream.on('end', flush).on('error', flush);\n  return throttled;\n};\n/**\n * If the proxy or config beforeRedirects functions are defined, call them with the options\n * object.\n *\n * @param {Object<string, any>} options - The options object that was passed to the request.\n *\n * @returns {Object<string, any>}\n */\n\n\nfunction dispatchBeforeRedirect(options, responseDetails) {\n  if (options.beforeRedirects.proxy) {\n    options.beforeRedirects.proxy(options);\n  }\n\n  if (options.beforeRedirects.config) {\n    options.beforeRedirects.config(options, responseDetails);\n  }\n}\n/**\n * If the proxy or config afterRedirects functions are defined, call them with the options\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} configProxy configuration from Axios options object\n * @param {string} location\n *\n * @returns {http.ClientRequestArgs}\n */\n\n\nfunction setProxy(options, configProxy, location) {\n  let proxy = configProxy;\n\n  if (!proxy && proxy !== false) {\n    const proxyUrl = proxyFromEnv.getProxyForUrl(location);\n\n    if (proxyUrl) {\n      proxy = new URL(proxyUrl);\n    }\n  }\n\n  if (proxy) {\n    // Basic proxy authorization\n    if (proxy.username) {\n      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');\n    }\n\n    if (proxy.auth) {\n      // Support proxy auth object form\n      if (proxy.auth.username || proxy.auth.password) {\n        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');\n      }\n\n      const base64 = Buffer.from(proxy.auth, 'utf8').toString('base64');\n      options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n    }\n\n    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');\n    const proxyHost = proxy.hostname || proxy.host;\n    options.hostname = proxyHost; // Replace 'host' since options is not a URL object\n\n    options.host = proxyHost;\n    options.port = proxy.port;\n    options.path = location;\n\n    if (proxy.protocol) {\n      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;\n    }\n  }\n\n  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {\n    // Configure proxy for redirected request, passing the original config proxy to apply\n    // the exact same logic as if the redirected request was performed by axios directly.\n    setProxy(redirectOptions, configProxy, redirectOptions.href);\n  };\n}\n\nconst isHttpAdapterSupported = typeof process !== 'undefined' && utils.kindOf(process) === 'process'; // temporary hotfix\n\nconst wrapAsync = asyncExecutor => {\n  return new Promise((resolve, reject) => {\n    let onDone;\n    let isDone;\n\n    const done = (value, isRejected) => {\n      if (isDone) return;\n      isDone = true;\n      onDone && onDone(value, isRejected);\n    };\n\n    const _resolve = value => {\n      done(value);\n      resolve(value);\n    };\n\n    const _reject = reason => {\n      done(reason, true);\n      reject(reason);\n    };\n\n    asyncExecutor(_resolve, _reject, onDoneHandler => onDone = onDoneHandler).catch(_reject);\n  });\n};\n\nconst resolveFamily = _ref2 => {\n  let {\n    address,\n    family\n  } = _ref2;\n\n  if (!utils.isString(address)) {\n    throw TypeError('address must be a string');\n  }\n\n  return {\n    address,\n    family: family || (address.indexOf('.') < 0 ? 6 : 4)\n  };\n};\n\nconst buildAddressEntry = (address, family) => resolveFamily(utils.isObject(address) ? address : {\n  address,\n  family\n});\n/*eslint consistent-return:0*/\n\n\nexport default isHttpAdapterSupported && function httpAdapter(config) {\n  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {\n    let {\n      data,\n      lookup,\n      family\n    } = config;\n    const {\n      responseType,\n      responseEncoding\n    } = config;\n    const method = config.method.toUpperCase();\n    let isDone;\n    let rejected = false;\n    let req;\n\n    if (lookup) {\n      const _lookup = callbackify(lookup, value => utils.isArray(value) ? value : [value]); // hotfix to support opt.all option which is required for node 20.x\n\n\n      lookup = (hostname, opt, cb) => {\n        _lookup(hostname, opt, (err, arg0, arg1) => {\n          if (err) {\n            return cb(err);\n          }\n\n          const addresses = utils.isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];\n          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);\n        });\n      };\n    } // temporary internal emitter until the AxiosRequest class will be implemented\n\n\n    const emitter = new EventEmitter();\n\n    const onFinished = () => {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(abort);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', abort);\n      }\n\n      emitter.removeAllListeners();\n    };\n\n    onDone((value, isRejected) => {\n      isDone = true;\n\n      if (isRejected) {\n        rejected = true;\n        onFinished();\n      }\n    });\n\n    function abort(reason) {\n      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);\n    }\n\n    emitter.once('abort', reject);\n\n    if (config.cancelToken || config.signal) {\n      config.cancelToken && config.cancelToken.subscribe(abort);\n\n      if (config.signal) {\n        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);\n      }\n    } // Parse url\n\n\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);\n    const protocol = parsed.protocol || supportedProtocols[0];\n\n    if (protocol === 'data:') {\n      let convertedData;\n\n      if (method !== 'GET') {\n        return settle(resolve, reject, {\n          status: 405,\n          statusText: 'method not allowed',\n          headers: {},\n          config\n        });\n      }\n\n      try {\n        convertedData = fromDataURI(config.url, responseType === 'blob', {\n          Blob: config.env && config.env.Blob\n        });\n      } catch (err) {\n        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);\n      }\n\n      if (responseType === 'text') {\n        convertedData = convertedData.toString(responseEncoding);\n\n        if (!responseEncoding || responseEncoding === 'utf8') {\n          convertedData = utils.stripBOM(convertedData);\n        }\n      } else if (responseType === 'stream') {\n        convertedData = stream.Readable.from(convertedData);\n      }\n\n      return settle(resolve, reject, {\n        data: convertedData,\n        status: 200,\n        statusText: 'OK',\n        headers: new AxiosHeaders(),\n        config\n      });\n    }\n\n    if (supportedProtocols.indexOf(protocol) === -1) {\n      return reject(new AxiosError('Unsupported protocol ' + protocol, AxiosError.ERR_BAD_REQUEST, config));\n    }\n\n    const headers = AxiosHeaders.from(config.headers).normalize(); // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n    // User-Agent is specified; handle case where no UA header is desired\n    // Only set header if it hasn't been set in config\n\n    headers.set('User-Agent', 'axios/' + VERSION, false);\n    const {\n      onUploadProgress,\n      onDownloadProgress\n    } = config;\n    const maxRate = config.maxRate;\n    let maxUploadRate = undefined;\n    let maxDownloadRate = undefined; // support for spec compliant FormData objects\n\n    if (utils.isSpecCompliantForm(data)) {\n      const userBoundary = headers.getContentType(/boundary=([-_\\w\\d]{10,70})/i);\n      data = formDataToStream(data, formHeaders => {\n        headers.set(formHeaders);\n      }, {\n        tag: `axios-${VERSION}-boundary`,\n        boundary: userBoundary && userBoundary[1] || undefined\n      }); // support for https://www.npmjs.com/package/form-data api\n    } else if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {\n      headers.set(data.getHeaders());\n\n      if (!headers.hasContentLength()) {\n        try {\n          const knownLength = await util.promisify(data.getLength).call(data);\n          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);\n          /*eslint no-empty:0*/\n        } catch (e) {}\n      }\n    } else if (utils.isBlob(data) || utils.isFile(data)) {\n      data.size && headers.setContentType(data.type || 'application/octet-stream');\n      headers.setContentLength(data.size || 0);\n      data = stream.Readable.from(readBlob(data));\n    } else if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {// Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(new AxiosError('Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream', AxiosError.ERR_BAD_REQUEST, config));\n      } // Add Content-Length header if data exists\n\n\n      headers.setContentLength(data.length, false);\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(new AxiosError('Request body larger than maxBodyLength limit', AxiosError.ERR_BAD_REQUEST, config));\n      }\n    }\n\n    const contentLength = utils.toFiniteNumber(headers.getContentLength());\n\n    if (utils.isArray(maxRate)) {\n      maxUploadRate = maxRate[0];\n      maxDownloadRate = maxRate[1];\n    } else {\n      maxUploadRate = maxDownloadRate = maxRate;\n    }\n\n    if (data && (onUploadProgress || maxUploadRate)) {\n      if (!utils.isStream(data)) {\n        data = stream.Readable.from(data, {\n          objectMode: false\n        });\n      }\n\n      data = stream.pipeline([data, new AxiosTransformStream({\n        maxRate: utils.toFiniteNumber(maxUploadRate)\n      })], utils.noop);\n      onUploadProgress && data.on('progress', flushOnFinish(data, progressEventDecorator(contentLength, progressEventReducer(asyncDecorator(onUploadProgress), false, 3))));\n    } // HTTP basic authentication\n\n\n    let auth = undefined;\n\n    if (config.auth) {\n      const username = config.auth.username || '';\n      const password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    if (!auth && parsed.username) {\n      const urlUsername = parsed.username;\n      const urlPassword = parsed.password;\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    auth && headers.delete('authorization');\n    let path;\n\n    try {\n      path = buildURL(parsed.pathname + parsed.search, config.params, config.paramsSerializer).replace(/^\\?/, '');\n    } catch (err) {\n      const customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      return reject(customErr);\n    }\n\n    headers.set('Accept-Encoding', 'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false);\n    const options = {\n      path,\n      method: method,\n      headers: headers.toJSON(),\n      agents: {\n        http: config.httpAgent,\n        https: config.httpsAgent\n      },\n      auth,\n      protocol,\n      family,\n      beforeRedirect: dispatchBeforeRedirect,\n      beforeRedirects: {}\n    }; // cacheable-lookup integration hotfix\n\n    !utils.isUndefined(lookup) && (options.lookup = lookup);\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname.startsWith(\"[\") ? parsed.hostname.slice(1, -1) : parsed.hostname;\n      options.port = parsed.port;\n      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n    }\n\n    let transport;\n    const isHttpsRequest = isHttps.test(options.protocol);\n    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsRequest ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n\n      if (config.beforeRedirect) {\n        options.beforeRedirects.config = config.beforeRedirect;\n      }\n\n      transport = isHttpsRequest ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    } else {\n      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited\n      options.maxBodyLength = Infinity;\n    }\n\n    if (config.insecureHTTPParser) {\n      options.insecureHTTPParser = config.insecureHTTPParser;\n    } // Create the request\n\n\n    req = transport.request(options, function handleResponse(res) {\n      if (req.destroyed) return;\n      const streams = [res];\n      const responseLength = +res.headers['content-length'];\n\n      if (onDownloadProgress || maxDownloadRate) {\n        const transformStream = new AxiosTransformStream({\n          maxRate: utils.toFiniteNumber(maxDownloadRate)\n        });\n        onDownloadProgress && transformStream.on('progress', flushOnFinish(transformStream, progressEventDecorator(responseLength, progressEventReducer(asyncDecorator(onDownloadProgress), true, 3))));\n        streams.push(transformStream);\n      } // decompress the response body transparently if required\n\n\n      let responseStream = res; // return the last request in case of redirects\n\n      const lastRequest = res.req || req; // if decompress disabled we should not decompress\n\n      if (config.decompress !== false && res.headers['content-encoding']) {\n        // if no content, but headers still say that it is encoded,\n        // remove the header not confuse downstream operations\n        if (method === 'HEAD' || res.statusCode === 204) {\n          delete res.headers['content-encoding'];\n        }\n\n        switch ((res.headers['content-encoding'] || '').toLowerCase()) {\n          /*eslint default-case:0*/\n          case 'gzip':\n          case 'x-gzip':\n          case 'compress':\n          case 'x-compress':\n            // add the unzipper to the body stream processing pipeline\n            streams.push(zlib.createUnzip(zlibOptions)); // remove the content-encoding in order to not confuse downstream operations\n\n            delete res.headers['content-encoding'];\n            break;\n\n          case 'deflate':\n            streams.push(new ZlibHeaderTransformStream()); // add the unzipper to the body stream processing pipeline\n\n            streams.push(zlib.createUnzip(zlibOptions)); // remove the content-encoding in order to not confuse downstream operations\n\n            delete res.headers['content-encoding'];\n            break;\n\n          case 'br':\n            if (isBrotliSupported) {\n              streams.push(zlib.createBrotliDecompress(brotliOptions));\n              delete res.headers['content-encoding'];\n            }\n\n        }\n      }\n\n      responseStream = streams.length > 1 ? stream.pipeline(streams, utils.noop) : streams[0];\n      const offListeners = stream.finished(responseStream, () => {\n        offListeners();\n        onFinished();\n      });\n      const response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: new AxiosHeaders(res.headers),\n        config,\n        request: lastRequest\n      };\n\n      if (responseType === 'stream') {\n        response.data = responseStream;\n        settle(resolve, reject, response);\n      } else {\n        const responseBuffer = [];\n        let totalResponseBytes = 0;\n        responseStream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n          totalResponseBytes += chunk.length; // make sure the content length is not over the maxContentLength if specified\n\n          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n            // stream.destroy() emit aborted event before calling reject() on Node.js v16\n            rejected = true;\n            responseStream.destroy();\n            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded', AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n          }\n        });\n        responseStream.on('aborted', function handlerStreamAborted() {\n          if (rejected) {\n            return;\n          }\n\n          const err = new AxiosError('stream has been aborted', AxiosError.ERR_BAD_RESPONSE, config, lastRequest);\n          responseStream.destroy(err);\n          reject(err);\n        });\n        responseStream.on('error', function handleStreamError(err) {\n          if (req.destroyed) return;\n          reject(AxiosError.from(err, null, config, lastRequest));\n        });\n        responseStream.on('end', function handleStreamEnd() {\n          try {\n            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n\n            if (responseType !== 'arraybuffer') {\n              responseData = responseData.toString(responseEncoding);\n\n              if (!responseEncoding || responseEncoding === 'utf8') {\n                responseData = utils.stripBOM(responseData);\n              }\n            }\n\n            response.data = responseData;\n          } catch (err) {\n            return reject(AxiosError.from(err, null, config, response.request, response));\n          }\n\n          settle(resolve, reject, response);\n        });\n      }\n\n      emitter.once('abort', err => {\n        if (!responseStream.destroyed) {\n          responseStream.emit('error', err);\n          responseStream.destroy();\n        }\n      });\n    });\n    emitter.once('abort', err => {\n      reject(err);\n      req.destroy(err);\n    }); // Handle errors\n\n    req.on('error', function handleRequestError(err) {\n      // @todo remove\n      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n      reject(AxiosError.from(err, null, config, req));\n    }); // set tcp keep alive to prevent drop connection by peer\n\n    req.on('socket', function handleRequestSocket(socket) {\n      // default interval of sending ack packet is 1 minute\n      socket.setKeepAlive(true, 1000 * 60);\n    }); // Handle request timeout\n\n    if (config.timeout) {\n      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n      const timeout = parseInt(config.timeout, 10);\n\n      if (Number.isNaN(timeout)) {\n        reject(new AxiosError('error trying to parse `config.timeout` to int', AxiosError.ERR_BAD_OPTION_VALUE, config, req));\n        return;\n      } // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devouring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n\n\n      req.setTimeout(timeout, function handleRequestTimeout() {\n        if (isDone) return;\n        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n        const transitional = config.transitional || transitionalDefaults;\n\n        if (config.timeoutErrorMessage) {\n          timeoutErrorMessage = config.timeoutErrorMessage;\n        }\n\n        reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, req));\n        abort();\n      });\n    } // Send the request\n\n\n    if (utils.isStream(data)) {\n      let ended = false;\n      let errored = false;\n      data.on('end', () => {\n        ended = true;\n      });\n      data.once('error', err => {\n        errored = true;\n        req.destroy(err);\n      });\n      data.on('close', () => {\n        if (!ended && !errored) {\n          abort(new CanceledError('Request stream has been aborted', config, req));\n        }\n      });\n      data.pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n};\nexport const __setProxy = setProxy;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/New folder/node_modules/axios/lib/adapters/http.js"],"names":["utils","settle","buildFullPath","buildURL","proxyFromEnv","http","https","util","followRedirects","zlib","VERSION","transitionalDefaults","AxiosError","CanceledError","platform","fromDataURI","stream","AxiosHeaders","AxiosTransformStream","EventEmitter","formDataToStream","readBlob","ZlibHeaderTransformStream","callbackify","progressEventReducer","progressEventDecorator","asyncDecorator","zlibOptions","flush","constants","Z_SYNC_FLUSH","finishFlush","brotliOptions","BROTLI_OPERATION_FLUSH","isBrotliSupported","isFunction","createBrotliDecompress","httpFollow","httpsFollow","isHttps","supportedProtocols","protocols","map","protocol","flushOnFinish","throttled","on","dispatchBeforeRedirect","options","responseDetails","beforeRedirects","proxy","config","setProxy","configProxy","location","proxyUrl","getProxyForUrl","URL","username","auth","password","base64","Buffer","from","toString","headers","host","hostname","port","proxyHost","path","includes","beforeRedirect","redirectOptions","href","isHttpAdapterSupported","process","kindOf","wrapAsync","asyncExecutor","Promise","resolve","reject","onDone","isDone","done","value","isRejected","_resolve","_reject","reason","onDoneHandler","catch","resolveFamily","address","family","isString","TypeError","indexOf","buildAddressEntry","isObject","httpAdapter","dispatchHttpRequest","data","lookup","responseType","responseEncoding","method","toUpperCase","rejected","req","_lookup","isArray","opt","cb","err","arg0","arg1","addresses","addr","all","emitter","onFinished","cancelToken","unsubscribe","abort","signal","removeEventListener","removeAllListeners","emit","type","once","subscribe","aborted","addEventListener","fullPath","baseURL","url","parsed","hasBrowserEnv","origin","undefined","convertedData","status","statusText","Blob","env","ERR_BAD_REQUEST","stripBOM","Readable","normalize","set","onUploadProgress","onDownloadProgress","maxRate","maxUploadRate","maxDownloadRate","isSpecCompliantForm","userBoundary","getContentType","formHeaders","tag","boundary","isFormData","getHeaders","hasContentLength","knownLength","promisify","getLength","call","Number","isFinite","setContentLength","e","isBlob","isFile","size","setContentType","isStream","isBuffer","isArrayBuffer","Uint8Array","length","maxBodyLength","contentLength","toFiniteNumber","getContentLength","objectMode","pipeline","noop","urlUsername","urlPassword","delete","pathname","search","params","paramsSerializer","replace","customErr","Error","message","exists","toJSON","agents","httpAgent","httpsAgent","isUndefined","socketPath","startsWith","slice","transport","isHttpsRequest","test","agent","maxRedirects","Infinity","insecureHTTPParser","request","handleResponse","res","destroyed","streams","responseLength","transformStream","push","responseStream","lastRequest","decompress","statusCode","toLowerCase","createUnzip","offListeners","finished","response","statusMessage","responseBuffer","totalResponseBytes","handleStreamData","chunk","maxContentLength","destroy","ERR_BAD_RESPONSE","handlerStreamAborted","handleStreamError","handleStreamEnd","responseData","concat","handleRequestError","handleRequestSocket","socket","setKeepAlive","timeout","parseInt","isNaN","ERR_BAD_OPTION_VALUE","setTimeout","handleRequestTimeout","timeoutErrorMessage","transitional","clarifyTimeoutError","ETIMEDOUT","ECONNABORTED","ended","errored","pipe","end","__setProxy"],"mappings":"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","sourcesContent":["'use strict';\n\nimport utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport buildFullPath from '../core/buildFullPath.js';\nimport buildURL from './../helpers/buildURL.js';\nimport proxyFromEnv from 'proxy-from-env';\nimport http from 'http';\nimport https from 'https';\nimport util from 'util';\nimport followRedirects from 'follow-redirects';\nimport zlib from 'zlib';\nimport {VERSION} from '../env/data.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport platform from '../platform/index.js';\nimport fromDataURI from '../helpers/fromDataURI.js';\nimport stream from 'stream';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport AxiosTransformStream from '../helpers/AxiosTransformStream.js';\nimport {EventEmitter} from 'events';\nimport formDataToStream from \"../helpers/formDataToStream.js\";\nimport readBlob from \"../helpers/readBlob.js\";\nimport ZlibHeaderTransformStream from '../helpers/ZlibHeaderTransformStream.js';\nimport callbackify from \"../helpers/callbackify.js\";\nimport {progressEventReducer, progressEventDecorator, asyncDecorator} from \"../helpers/progressEventReducer.js\";\n\nconst zlibOptions = {\n  flush: zlib.constants.Z_SYNC_FLUSH,\n  finishFlush: zlib.constants.Z_SYNC_FLUSH\n};\n\nconst brotliOptions = {\n  flush: zlib.constants.BROTLI_OPERATION_FLUSH,\n  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH\n}\n\nconst isBrotliSupported = utils.isFunction(zlib.createBrotliDecompress);\n\nconst {http: httpFollow, https: httpsFollow} = followRedirects;\n\nconst isHttps = /https:?/;\n\nconst supportedProtocols = platform.protocols.map(protocol => {\n  return protocol + ':';\n});\n\nconst flushOnFinish = (stream, [throttled, flush]) => {\n  stream\n    .on('end', flush)\n    .on('error', flush);\n\n  return throttled;\n}\n\n/**\n * If the proxy or config beforeRedirects functions are defined, call them with the options\n * object.\n *\n * @param {Object<string, any>} options - The options object that was passed to the request.\n *\n * @returns {Object<string, any>}\n */\nfunction dispatchBeforeRedirect(options, responseDetails) {\n  if (options.beforeRedirects.proxy) {\n    options.beforeRedirects.proxy(options);\n  }\n  if (options.beforeRedirects.config) {\n    options.beforeRedirects.config(options, responseDetails);\n  }\n}\n\n/**\n * If the proxy or config afterRedirects functions are defined, call them with the options\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} configProxy configuration from Axios options object\n * @param {string} location\n *\n * @returns {http.ClientRequestArgs}\n */\nfunction setProxy(options, configProxy, location) {\n  let proxy = configProxy;\n  if (!proxy && proxy !== false) {\n    const proxyUrl = proxyFromEnv.getProxyForUrl(location);\n    if (proxyUrl) {\n      proxy = new URL(proxyUrl);\n    }\n  }\n  if (proxy) {\n    // Basic proxy authorization\n    if (proxy.username) {\n      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');\n    }\n\n    if (proxy.auth) {\n      // Support proxy auth object form\n      if (proxy.auth.username || proxy.auth.password) {\n        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');\n      }\n      const base64 = Buffer\n        .from(proxy.auth, 'utf8')\n        .toString('base64');\n      options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n    }\n\n    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');\n    const proxyHost = proxy.hostname || proxy.host;\n    options.hostname = proxyHost;\n    // Replace 'host' since options is not a URL object\n    options.host = proxyHost;\n    options.port = proxy.port;\n    options.path = location;\n    if (proxy.protocol) {\n      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;\n    }\n  }\n\n  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {\n    // Configure proxy for redirected request, passing the original config proxy to apply\n    // the exact same logic as if the redirected request was performed by axios directly.\n    setProxy(redirectOptions, configProxy, redirectOptions.href);\n  };\n}\n\nconst isHttpAdapterSupported = typeof process !== 'undefined' && utils.kindOf(process) === 'process';\n\n// temporary hotfix\n\nconst wrapAsync = (asyncExecutor) => {\n  return new Promise((resolve, reject) => {\n    let onDone;\n    let isDone;\n\n    const done = (value, isRejected) => {\n      if (isDone) return;\n      isDone = true;\n      onDone && onDone(value, isRejected);\n    }\n\n    const _resolve = (value) => {\n      done(value);\n      resolve(value);\n    };\n\n    const _reject = (reason) => {\n      done(reason, true);\n      reject(reason);\n    }\n\n    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);\n  })\n};\n\nconst resolveFamily = ({address, family}) => {\n  if (!utils.isString(address)) {\n    throw TypeError('address must be a string');\n  }\n  return ({\n    address,\n    family: family || (address.indexOf('.') < 0 ? 6 : 4)\n  });\n}\n\nconst buildAddressEntry = (address, family) => resolveFamily(utils.isObject(address) ? address : {address, family});\n\n/*eslint consistent-return:0*/\nexport default isHttpAdapterSupported && function httpAdapter(config) {\n  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {\n    let {data, lookup, family} = config;\n    const {responseType, responseEncoding} = config;\n    const method = config.method.toUpperCase();\n    let isDone;\n    let rejected = false;\n    let req;\n\n    if (lookup) {\n      const _lookup = callbackify(lookup, (value) => utils.isArray(value) ? value : [value]);\n      // hotfix to support opt.all option which is required for node 20.x\n      lookup = (hostname, opt, cb) => {\n        _lookup(hostname, opt, (err, arg0, arg1) => {\n          if (err) {\n            return cb(err);\n          }\n\n          const addresses = utils.isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];\n\n          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);\n        });\n      }\n    }\n\n    // temporary internal emitter until the AxiosRequest class will be implemented\n    const emitter = new EventEmitter();\n\n    const onFinished = () => {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(abort);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', abort);\n      }\n\n      emitter.removeAllListeners();\n    }\n\n    onDone((value, isRejected) => {\n      isDone = true;\n      if (isRejected) {\n        rejected = true;\n        onFinished();\n      }\n    });\n\n    function abort(reason) {\n      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);\n    }\n\n    emitter.once('abort', reject);\n\n    if (config.cancelToken || config.signal) {\n      config.cancelToken && config.cancelToken.subscribe(abort);\n      if (config.signal) {\n        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);\n      }\n    }\n\n    // Parse url\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);\n    const protocol = parsed.protocol || supportedProtocols[0];\n\n    if (protocol === 'data:') {\n      let convertedData;\n\n      if (method !== 'GET') {\n        return settle(resolve, reject, {\n          status: 405,\n          statusText: 'method not allowed',\n          headers: {},\n          config\n        });\n      }\n\n      try {\n        convertedData = fromDataURI(config.url, responseType === 'blob', {\n          Blob: config.env && config.env.Blob\n        });\n      } catch (err) {\n        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);\n      }\n\n      if (responseType === 'text') {\n        convertedData = convertedData.toString(responseEncoding);\n\n        if (!responseEncoding || responseEncoding === 'utf8') {\n          convertedData = utils.stripBOM(convertedData);\n        }\n      } else if (responseType === 'stream') {\n        convertedData = stream.Readable.from(convertedData);\n      }\n\n      return settle(resolve, reject, {\n        data: convertedData,\n        status: 200,\n        statusText: 'OK',\n        headers: new AxiosHeaders(),\n        config\n      });\n    }\n\n    if (supportedProtocols.indexOf(protocol) === -1) {\n      return reject(new AxiosError(\n        'Unsupported protocol ' + protocol,\n        AxiosError.ERR_BAD_REQUEST,\n        config\n      ));\n    }\n\n    const headers = AxiosHeaders.from(config.headers).normalize();\n\n    // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n    // User-Agent is specified; handle case where no UA header is desired\n    // Only set header if it hasn't been set in config\n    headers.set('User-Agent', 'axios/' + VERSION, false);\n\n    const {onUploadProgress, onDownloadProgress} = config;\n    const maxRate = config.maxRate;\n    let maxUploadRate = undefined;\n    let maxDownloadRate = undefined;\n\n    // support for spec compliant FormData objects\n    if (utils.isSpecCompliantForm(data)) {\n      const userBoundary = headers.getContentType(/boundary=([-_\\w\\d]{10,70})/i);\n\n      data = formDataToStream(data, (formHeaders) => {\n        headers.set(formHeaders);\n      }, {\n        tag: `axios-${VERSION}-boundary`,\n        boundary: userBoundary && userBoundary[1] || undefined\n      });\n      // support for https://www.npmjs.com/package/form-data api\n    } else if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {\n      headers.set(data.getHeaders());\n\n      if (!headers.hasContentLength()) {\n        try {\n          const knownLength = await util.promisify(data.getLength).call(data);\n          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);\n          /*eslint no-empty:0*/\n        } catch (e) {\n        }\n      }\n    } else if (utils.isBlob(data) || utils.isFile(data)) {\n      data.size && headers.setContentType(data.type || 'application/octet-stream');\n      headers.setContentLength(data.size || 0);\n      data = stream.Readable.from(readBlob(data));\n    } else if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(new AxiosError(\n          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n\n      // Add Content-Length header if data exists\n      headers.setContentLength(data.length, false);\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(new AxiosError(\n          'Request body larger than maxBodyLength limit',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n    }\n\n    const contentLength = utils.toFiniteNumber(headers.getContentLength());\n\n    if (utils.isArray(maxRate)) {\n      maxUploadRate = maxRate[0];\n      maxDownloadRate = maxRate[1];\n    } else {\n      maxUploadRate = maxDownloadRate = maxRate;\n    }\n\n    if (data && (onUploadProgress || maxUploadRate)) {\n      if (!utils.isStream(data)) {\n        data = stream.Readable.from(data, {objectMode: false});\n      }\n\n      data = stream.pipeline([data, new AxiosTransformStream({\n        maxRate: utils.toFiniteNumber(maxUploadRate)\n      })], utils.noop);\n\n      onUploadProgress && data.on('progress', flushOnFinish(\n        data,\n        progressEventDecorator(\n          contentLength,\n          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)\n        )\n      ));\n    }\n\n    // HTTP basic authentication\n    let auth = undefined;\n    if (config.auth) {\n      const username = config.auth.username || '';\n      const password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    if (!auth && parsed.username) {\n      const urlUsername = parsed.username;\n      const urlPassword = parsed.password;\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    auth && headers.delete('authorization');\n\n    let path;\n\n    try {\n      path = buildURL(\n        parsed.pathname + parsed.search,\n        config.params,\n        config.paramsSerializer\n      ).replace(/^\\?/, '');\n    } catch (err) {\n      const customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      return reject(customErr);\n    }\n\n    headers.set(\n      'Accept-Encoding',\n      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false\n      );\n\n    const options = {\n      path,\n      method: method,\n      headers: headers.toJSON(),\n      agents: { http: config.httpAgent, https: config.httpsAgent },\n      auth,\n      protocol,\n      family,\n      beforeRedirect: dispatchBeforeRedirect,\n      beforeRedirects: {}\n    };\n\n    // cacheable-lookup integration hotfix\n    !utils.isUndefined(lookup) && (options.lookup = lookup);\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname.startsWith(\"[\") ? parsed.hostname.slice(1, -1) : parsed.hostname;\n      options.port = parsed.port;\n      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n    }\n\n    let transport;\n    const isHttpsRequest = isHttps.test(options.protocol);\n    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsRequest ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n      if (config.beforeRedirect) {\n        options.beforeRedirects.config = config.beforeRedirect;\n      }\n      transport = isHttpsRequest ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    } else {\n      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited\n      options.maxBodyLength = Infinity;\n    }\n\n    if (config.insecureHTTPParser) {\n      options.insecureHTTPParser = config.insecureHTTPParser;\n    }\n\n    // Create the request\n    req = transport.request(options, function handleResponse(res) {\n      if (req.destroyed) return;\n\n      const streams = [res];\n\n      const responseLength = +res.headers['content-length'];\n\n      if (onDownloadProgress || maxDownloadRate) {\n        const transformStream = new AxiosTransformStream({\n          maxRate: utils.toFiniteNumber(maxDownloadRate)\n        });\n\n        onDownloadProgress && transformStream.on('progress', flushOnFinish(\n          transformStream,\n          progressEventDecorator(\n            responseLength,\n            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)\n          )\n        ));\n\n        streams.push(transformStream);\n      }\n\n      // decompress the response body transparently if required\n      let responseStream = res;\n\n      // return the last request in case of redirects\n      const lastRequest = res.req || req;\n\n      // if decompress disabled we should not decompress\n      if (config.decompress !== false && res.headers['content-encoding']) {\n        // if no content, but headers still say that it is encoded,\n        // remove the header not confuse downstream operations\n        if (method === 'HEAD' || res.statusCode === 204) {\n          delete res.headers['content-encoding'];\n        }\n\n        switch ((res.headers['content-encoding'] || '').toLowerCase()) {\n        /*eslint default-case:0*/\n        case 'gzip':\n        case 'x-gzip':\n        case 'compress':\n        case 'x-compress':\n          // add the unzipper to the body stream processing pipeline\n          streams.push(zlib.createUnzip(zlibOptions));\n\n          // remove the content-encoding in order to not confuse downstream operations\n          delete res.headers['content-encoding'];\n          break;\n        case 'deflate':\n          streams.push(new ZlibHeaderTransformStream());\n\n          // add the unzipper to the body stream processing pipeline\n          streams.push(zlib.createUnzip(zlibOptions));\n\n          // remove the content-encoding in order to not confuse downstream operations\n          delete res.headers['content-encoding'];\n          break;\n        case 'br':\n          if (isBrotliSupported) {\n            streams.push(zlib.createBrotliDecompress(brotliOptions));\n            delete res.headers['content-encoding'];\n          }\n        }\n      }\n\n      responseStream = streams.length > 1 ? stream.pipeline(streams, utils.noop) : streams[0];\n\n      const offListeners = stream.finished(responseStream, () => {\n        offListeners();\n        onFinished();\n      });\n\n      const response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: new AxiosHeaders(res.headers),\n        config,\n        request: lastRequest\n      };\n\n      if (responseType === 'stream') {\n        response.data = responseStream;\n        settle(resolve, reject, response);\n      } else {\n        const responseBuffer = [];\n        let totalResponseBytes = 0;\n\n        responseStream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n          totalResponseBytes += chunk.length;\n\n          // make sure the content length is not over the maxContentLength if specified\n          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n            // stream.destroy() emit aborted event before calling reject() on Node.js v16\n            rejected = true;\n            responseStream.destroy();\n            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',\n              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n          }\n        });\n\n        responseStream.on('aborted', function handlerStreamAborted() {\n          if (rejected) {\n            return;\n          }\n\n          const err = new AxiosError(\n            'stream has been aborted',\n            AxiosError.ERR_BAD_RESPONSE,\n            config,\n            lastRequest\n          );\n          responseStream.destroy(err);\n          reject(err);\n        });\n\n        responseStream.on('error', function handleStreamError(err) {\n          if (req.destroyed) return;\n          reject(AxiosError.from(err, null, config, lastRequest));\n        });\n\n        responseStream.on('end', function handleStreamEnd() {\n          try {\n            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n            if (responseType !== 'arraybuffer') {\n              responseData = responseData.toString(responseEncoding);\n              if (!responseEncoding || responseEncoding === 'utf8') {\n                responseData = utils.stripBOM(responseData);\n              }\n            }\n            response.data = responseData;\n          } catch (err) {\n            return reject(AxiosError.from(err, null, config, response.request, response));\n          }\n          settle(resolve, reject, response);\n        });\n      }\n\n      emitter.once('abort', err => {\n        if (!responseStream.destroyed) {\n          responseStream.emit('error', err);\n          responseStream.destroy();\n        }\n      });\n    });\n\n    emitter.once('abort', err => {\n      reject(err);\n      req.destroy(err);\n    });\n\n    // Handle errors\n    req.on('error', function handleRequestError(err) {\n      // @todo remove\n      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n      reject(AxiosError.from(err, null, config, req));\n    });\n\n    // set tcp keep alive to prevent drop connection by peer\n    req.on('socket', function handleRequestSocket(socket) {\n      // default interval of sending ack packet is 1 minute\n      socket.setKeepAlive(true, 1000 * 60);\n    });\n\n    // Handle request timeout\n    if (config.timeout) {\n      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n      const timeout = parseInt(config.timeout, 10);\n\n      if (Number.isNaN(timeout)) {\n        reject(new AxiosError(\n          'error trying to parse `config.timeout` to int',\n          AxiosError.ERR_BAD_OPTION_VALUE,\n          config,\n          req\n        ));\n\n        return;\n      }\n\n      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devouring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n      req.setTimeout(timeout, function handleRequestTimeout() {\n        if (isDone) return;\n        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n        const transitional = config.transitional || transitionalDefaults;\n        if (config.timeoutErrorMessage) {\n          timeoutErrorMessage = config.timeoutErrorMessage;\n        }\n        reject(new AxiosError(\n          timeoutErrorMessage,\n          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n          config,\n          req\n        ));\n        abort();\n      });\n    }\n\n\n    // Send the request\n    if (utils.isStream(data)) {\n      let ended = false;\n      let errored = false;\n\n      data.on('end', () => {\n        ended = true;\n      });\n\n      data.once('error', err => {\n        errored = true;\n        req.destroy(err);\n      });\n\n      data.on('close', () => {\n        if (!ended && !errored) {\n          abort(new CanceledError('Request stream has been aborted', config, req));\n        }\n      });\n\n      data.pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n}\n\nexport const __setProxy = setProxy;\n"]},"metadata":{},"sourceType":"module"}