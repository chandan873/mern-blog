{"ast":null,"code":"var url = require(\"url\");\n\nvar URL = url.URL;\n\nvar http = require(\"http\");\n\nvar https = require(\"https\");\n\nvar Writable = require(\"stream\").Writable;\n\nvar assert = require(\"assert\");\n\nvar debug = require(\"./debug\"); // Preventive platform detection\n// istanbul ignore next\n\n\n(function detectUnsupportedEnvironment() {\n  var looksLikeNode = typeof process !== \"undefined\";\n  var looksLikeBrowser = typeof window !== \"undefined\" && typeof document !== \"undefined\";\n  var looksLikeV8 = isFunction(Error.captureStackTrace);\n\n  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {\n    console.warn(\"The follow-redirects package should be excluded from browser builds.\");\n  }\n})(); // Whether to use the native URL object or the legacy url module\n\n\nvar useNativeURL = false;\n\ntry {\n  assert(new URL(\"\"));\n} catch (error) {\n  useNativeURL = error.code === \"ERR_INVALID_URL\";\n} // URL fields to preserve in copy operations\n\n\nvar preservedUrlFields = [\"auth\", \"host\", \"hostname\", \"href\", \"path\", \"pathname\", \"port\", \"protocol\", \"query\", \"search\", \"hash\"]; // Create handlers that pass events from native requests\n\nvar events = [\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"];\nvar eventHandlers = Object.create(null);\nevents.forEach(function (event) {\n  eventHandlers[event] = function (arg1, arg2, arg3) {\n    this._redirectable.emit(event, arg1, arg2, arg3);\n  };\n}); // Error types with codes\n\nvar InvalidUrlError = createErrorType(\"ERR_INVALID_URL\", \"Invalid URL\", TypeError);\nvar RedirectionError = createErrorType(\"ERR_FR_REDIRECTION_FAILURE\", \"Redirected request failed\");\nvar TooManyRedirectsError = createErrorType(\"ERR_FR_TOO_MANY_REDIRECTS\", \"Maximum number of redirects exceeded\", RedirectionError);\nvar MaxBodyLengthExceededError = createErrorType(\"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\", \"Request body larger than maxBodyLength limit\");\nvar WriteAfterEndError = createErrorType(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\"); // istanbul ignore next\n\nvar destroy = Writable.prototype.destroy || noop; // An HTTP(S) request that can be redirected\n\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n\n  this._sanitizeOptions(options);\n\n  this._options = options;\n  this._ended = false;\n  this._ending = false;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = []; // Attach a callback if passed\n\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  } // React to responses of native requests\n\n\n  var self = this;\n\n  this._onNativeResponse = function (response) {\n    try {\n      self._processResponse(response);\n    } catch (cause) {\n      self.emit(\"error\", cause instanceof RedirectionError ? cause : new RedirectionError({\n        cause: cause\n      }));\n    }\n  }; // Perform the first request\n\n\n  this._performRequest();\n}\n\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\nRedirectableRequest.prototype.abort = function () {\n  destroyRequest(this._currentRequest);\n\n  this._currentRequest.abort();\n\n  this.emit(\"abort\");\n};\n\nRedirectableRequest.prototype.destroy = function (error) {\n  destroyRequest(this._currentRequest, error);\n  destroy.call(this, error);\n  return this;\n}; // Writes buffered data to the current native request\n\n\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Writing is not allowed if end has been called\n  if (this._ending) {\n    throw new WriteAfterEndError();\n  } // Validate input and shift parameters if necessary\n\n\n  if (!isString(data) && !isBuffer(data)) {\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\n  }\n\n  if (isFunction(encoding)) {\n    callback = encoding;\n    encoding = null;\n  } // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n\n\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n\n    return;\n  } // Only write when we don't exceed the maximum body length\n\n\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n\n    this._requestBodyBuffers.push({\n      data: data,\n      encoding: encoding\n    });\n\n    this._currentRequest.write(data, encoding, callback);\n  } // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new MaxBodyLengthExceededError());\n    this.abort();\n  }\n}; // Ends the current native request\n\n\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (isFunction(data)) {\n    callback = data;\n    data = encoding = null;\n  } else if (isFunction(encoding)) {\n    callback = encoding;\n    encoding = null;\n  } // Write data if needed and end\n\n\n  if (!data) {\n    this._ended = this._ending = true;\n\n    this._currentRequest.end(null, null, callback);\n  } else {\n    var self = this;\n    var currentRequest = this._currentRequest;\n    this.write(data, encoding, function () {\n      self._ended = true;\n      currentRequest.end(null, null, callback);\n    });\n    this._ending = true;\n  }\n}; // Sets a header value on the current native request\n\n\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n\n  this._currentRequest.setHeader(name, value);\n}; // Clears a header value on the current native request\n\n\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n\n  this._currentRequest.removeHeader(name);\n}; // Global timeout for all underlying requests\n\n\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\n  var self = this; // Destroys the socket on timeout\n\n  function destroyOnTimeout(socket) {\n    socket.setTimeout(msecs);\n    socket.removeListener(\"timeout\", socket.destroy);\n    socket.addListener(\"timeout\", socket.destroy);\n  } // Sets up a timer to trigger a timeout event\n\n\n  function startTimer(socket) {\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n    }\n\n    self._timeout = setTimeout(function () {\n      self.emit(\"timeout\");\n      clearTimer();\n    }, msecs);\n    destroyOnTimeout(socket);\n  } // Stops a timeout from triggering\n\n\n  function clearTimer() {\n    // Clear the timeout\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n      self._timeout = null;\n    } // Clean up all attached listeners\n\n\n    self.removeListener(\"abort\", clearTimer);\n    self.removeListener(\"error\", clearTimer);\n    self.removeListener(\"response\", clearTimer);\n    self.removeListener(\"close\", clearTimer);\n\n    if (callback) {\n      self.removeListener(\"timeout\", callback);\n    }\n\n    if (!self.socket) {\n      self._currentRequest.removeListener(\"socket\", startTimer);\n    }\n  } // Attach callback if passed\n\n\n  if (callback) {\n    this.on(\"timeout\", callback);\n  } // Start the timer if or when the socket is opened\n\n\n  if (this.socket) {\n    startTimer(this.socket);\n  } else {\n    this._currentRequest.once(\"socket\", startTimer);\n  } // Clean up on events\n\n\n  this.on(\"socket\", destroyOnTimeout);\n  this.on(\"abort\", clearTimer);\n  this.on(\"error\", clearTimer);\n  this.on(\"response\", clearTimer);\n  this.on(\"close\", clearTimer);\n  return this;\n}; // Proxy all other public ClientRequest methods\n\n\n[\"flushHeaders\", \"getHeader\", \"setNoDelay\", \"setSocketKeepAlive\"].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n}); // Proxy all public ClientRequest properties\n\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () {\n      return this._currentRequest[property];\n    }\n  });\n});\n\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\n  // Ensure headers are always present\n  if (!options.headers) {\n    options.headers = {};\n  } // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n\n\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n\n    delete options.host;\n  } // Complete the URL object when necessary\n\n\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    } else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n}; // Executes the next native request (initial or redirect)\n\n\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n\n  if (!nativeProtocol) {\n    throw new TypeError(\"Unsupported protocol \" + protocol);\n  } // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n\n\n  if (this._options.agents) {\n    var scheme = protocol.slice(0, -1);\n    this._options.agent = this._options.agents[scheme];\n  } // Create the native request and set up its event handlers\n\n\n  var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);\n  request._redirectable = this;\n\n  for (var event of events) {\n    request.on(event, eventHandlers[event]);\n  } // RFC7230§5.3.1: When making a request directly to an origin server, […]\n  // a client MUST send only the absolute path […] as the request-target.\n\n\n  this._currentUrl = /^\\//.test(this._options.path) ? url.format(this._options) : // When making a request to a proxy, […]\n  // a client MUST send the target URI in absolute-form […].\n  this._options.path; // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n\n  if (this._isRedirect) {\n    // Write the request entity and end\n    var i = 0;\n    var self = this;\n    var buffers = this._requestBodyBuffers;\n\n    (function writeNext(error) {\n      // Only write if this request has not been redirected yet\n      // istanbul ignore else\n      if (request === self._currentRequest) {\n        // Report any write errors\n        // istanbul ignore if\n        if (error) {\n          self.emit(\"error\", error);\n        } // Write the next buffer if there are still left\n        else if (i < buffers.length) {\n          var buffer = buffers[i++]; // istanbul ignore else\n\n          if (!request.finished) {\n            request.write(buffer.data, buffer.encoding, writeNext);\n          }\n        } // End the request if `end` has been called on us\n        else if (self._ended) {\n          request.end();\n        }\n      }\n    })();\n  }\n}; // Processes a response from the current native request\n\n\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  var statusCode = response.statusCode;\n\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: statusCode\n    });\n  } // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n  // If the response is not a redirect; return it as-is\n\n\n  var location = response.headers.location;\n\n  if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response); // Clean up\n\n    this._requestBodyBuffers = [];\n    return;\n  } // The response is a redirect, so abort the current request\n\n\n  destroyRequest(this._currentRequest); // Discard the remainder of the response to avoid waiting for data\n\n  response.destroy(); // RFC7231§6.4: A client SHOULD detect and intervene\n  // in cyclical redirections (i.e., \"infinite\" redirection loops).\n\n  if (++this._redirectCount > this._options.maxRedirects) {\n    throw new TooManyRedirectsError();\n  } // Store the request headers if applicable\n\n\n  var requestHeaders;\n  var beforeRedirect = this._options.beforeRedirect;\n\n  if (beforeRedirect) {\n    requestHeaders = Object.assign({\n      // The Host header was set by nativeProtocol.request\n      Host: response.req.getHeader(\"host\")\n    }, this._options.headers);\n  } // RFC7231§6.4: Automatic redirection needs to done with\n  // care for methods not known to be safe, […]\n  // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change\n  // the request method from POST to GET for the subsequent request.\n\n\n  var method = this._options.method;\n\n  if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that\n  // the server is redirecting the user agent to a different resource […]\n  // A user agent can perform a retrieval request targeting that URI\n  // (a GET or HEAD request if using HTTP) […]\n  statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {\n    this._options.method = \"GET\"; // Drop a possible entity and headers related to it\n\n    this._requestBodyBuffers = [];\n    removeMatchingHeaders(/^content-/i, this._options.headers);\n  } // Drop the Host header, as the redirect might lead to a different host\n\n\n  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers); // If the redirect is relative, carry over the host of the last request\n\n  var currentUrlParts = parseUrl(this._currentUrl);\n  var currentHost = currentHostHeader || currentUrlParts.host;\n  var currentUrl = /^\\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, {\n    host: currentHost\n  })); // Create the redirected request\n\n  var redirectUrl = resolveUrl(location, currentUrl);\n  debug(\"redirecting to\", redirectUrl.href);\n  this._isRedirect = true;\n  spreadUrlObject(redirectUrl, this._options); // Drop confidential headers when redirecting to a less secure protocol\n  // or to a different domain that is not a superdomain\n\n  if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== \"https:\" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {\n    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);\n  } // Evaluate the beforeRedirect callback\n\n\n  if (isFunction(beforeRedirect)) {\n    var responseDetails = {\n      headers: response.headers,\n      statusCode: statusCode\n    };\n    var requestDetails = {\n      url: currentUrl,\n      method: method,\n      headers: requestHeaders\n    };\n    beforeRedirect(this._options, responseDetails, requestDetails);\n\n    this._sanitizeOptions(this._options);\n  } // Perform the redirected request\n\n\n  this._performRequest();\n}; // Wraps the key/value object of protocols with redirect functionality\n\n\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024\n  }; // Wrap each protocol\n\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol); // Executes a request, following redirects\n\n    function request(input, options, callback) {\n      // Parse parameters, ensuring that input is an object\n      if (isURL(input)) {\n        input = spreadUrlObject(input);\n      } else if (isString(input)) {\n        input = spreadUrlObject(parseUrl(input));\n      } else {\n        callback = options;\n        options = validateUrl(input);\n        input = {\n          protocol: protocol\n        };\n      }\n\n      if (isFunction(options)) {\n        callback = options;\n        options = null;\n      } // Set defaults\n\n\n      options = Object.assign({\n        maxRedirects: exports.maxRedirects,\n        maxBodyLength: exports.maxBodyLength\n      }, input, options);\n      options.nativeProtocols = nativeProtocols;\n\n      if (!isString(options.host) && !isString(options.hostname)) {\n        options.hostname = \"::1\";\n      }\n\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    } // Executes a GET request, following redirects\n\n\n    function get(input, options, callback) {\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\n      wrappedRequest.end();\n      return wrappedRequest;\n    } // Expose the properties on the wrapped protocol\n\n\n    Object.defineProperties(wrappedProtocol, {\n      request: {\n        value: request,\n        configurable: true,\n        enumerable: true,\n        writable: true\n      },\n      get: {\n        value: get,\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }\n    });\n  });\n  return exports;\n}\n\nfunction noop() {\n  /* empty */\n}\n\nfunction parseUrl(input) {\n  var parsed; // istanbul ignore else\n\n  if (useNativeURL) {\n    parsed = new URL(input);\n  } else {\n    // Ensure the URL is valid and absolute\n    parsed = validateUrl(url.parse(input));\n\n    if (!isString(parsed.protocol)) {\n      throw new InvalidUrlError({\n        input\n      });\n    }\n  }\n\n  return parsed;\n}\n\nfunction resolveUrl(relative, base) {\n  // istanbul ignore next\n  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));\n}\n\nfunction validateUrl(input) {\n  if (/^\\[/.test(input.hostname) && !/^\\[[:0-9a-f]+\\]$/i.test(input.hostname)) {\n    throw new InvalidUrlError({\n      input: input.href || input\n    });\n  }\n\n  if (/^\\[/.test(input.host) && !/^\\[[:0-9a-f]+\\](:\\d+)?$/i.test(input.host)) {\n    throw new InvalidUrlError({\n      input: input.href || input\n    });\n  }\n\n  return input;\n}\n\nfunction spreadUrlObject(urlObject, target) {\n  var spread = target || {};\n\n  for (var key of preservedUrlFields) {\n    spread[key] = urlObject[key];\n  } // Fix IPv6 hostname\n\n\n  if (spread.hostname.startsWith(\"[\")) {\n    spread.hostname = spread.hostname.slice(1, -1);\n  } // Ensure port is a number\n\n\n  if (spread.port !== \"\") {\n    spread.port = Number(spread.port);\n  } // Concatenate path\n\n\n  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;\n  return spread;\n}\n\nfunction removeMatchingHeaders(regex, headers) {\n  var lastValue;\n\n  for (var header in headers) {\n    if (regex.test(header)) {\n      lastValue = headers[header];\n      delete headers[header];\n    }\n  }\n\n  return lastValue === null || typeof lastValue === \"undefined\" ? undefined : String(lastValue).trim();\n}\n\nfunction createErrorType(code, message, baseClass) {\n  // Create constructor\n  function CustomError(properties) {\n    // istanbul ignore else\n    if (isFunction(Error.captureStackTrace)) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    Object.assign(this, properties || {});\n    this.code = code;\n    this.message = this.cause ? message + \": \" + this.cause.message : message;\n  } // Attach constructor and set default properties\n\n\n  CustomError.prototype = new (baseClass || Error)();\n  Object.defineProperties(CustomError.prototype, {\n    constructor: {\n      value: CustomError,\n      enumerable: false\n    },\n    name: {\n      value: \"Error [\" + code + \"]\",\n      enumerable: false\n    }\n  });\n  return CustomError;\n}\n\nfunction destroyRequest(request, error) {\n  for (var event of events) {\n    request.removeListener(event, eventHandlers[event]);\n  }\n\n  request.on(\"error\", noop);\n  request.destroy(error);\n}\n\nfunction isSubdomain(subdomain, domain) {\n  assert(isString(subdomain) && isString(domain));\n  var dot = subdomain.length - domain.length - 1;\n  return dot > 0 && subdomain[dot] === \".\" && subdomain.endsWith(domain);\n}\n\nfunction isString(value) {\n  return typeof value === \"string\" || value instanceof String;\n}\n\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\n\nfunction isBuffer(value) {\n  return typeof value === \"object\" && \"length\" in value;\n}\n\nfunction isURL(value) {\n  return URL && value instanceof URL;\n} // Exports\n\n\nmodule.exports = wrap({\n  http: http,\n  https: https\n});\nmodule.exports.wrap = wrap;","map":{"version":3,"sources":["C:/Users/Administrator/Desktop/New folder/node_modules/follow-redirects/index.js"],"names":["url","require","URL","http","https","Writable","assert","debug","detectUnsupportedEnvironment","looksLikeNode","process","looksLikeBrowser","window","document","looksLikeV8","isFunction","Error","captureStackTrace","console","warn","useNativeURL","error","code","preservedUrlFields","events","eventHandlers","Object","create","forEach","event","arg1","arg2","arg3","_redirectable","emit","InvalidUrlError","createErrorType","TypeError","RedirectionError","TooManyRedirectsError","MaxBodyLengthExceededError","WriteAfterEndError","destroy","prototype","noop","RedirectableRequest","options","responseCallback","call","_sanitizeOptions","_options","_ended","_ending","_redirectCount","_redirects","_requestBodyLength","_requestBodyBuffers","on","self","_onNativeResponse","response","_processResponse","cause","_performRequest","abort","destroyRequest","_currentRequest","write","data","encoding","callback","isString","isBuffer","length","maxBodyLength","push","end","currentRequest","setHeader","name","value","headers","removeHeader","setTimeout","msecs","destroyOnTimeout","socket","removeListener","addListener","startTimer","_timeout","clearTimeout","clearTimer","once","method","a","b","property","defineProperty","get","host","hostname","pathname","path","searchPos","indexOf","substring","search","protocol","nativeProtocol","nativeProtocols","agents","scheme","slice","agent","request","_currentUrl","test","format","_isRedirect","i","buffers","writeNext","buffer","finished","statusCode","trackRedirects","location","followRedirects","responseUrl","redirects","maxRedirects","requestHeaders","beforeRedirect","assign","Host","req","getHeader","removeMatchingHeaders","currentHostHeader","currentUrlParts","parseUrl","currentHost","currentUrl","redirectUrl","resolveUrl","href","spreadUrlObject","isSubdomain","responseDetails","requestDetails","wrap","protocols","exports","keys","wrappedProtocol","input","isURL","validateUrl","equal","wrappedRequest","defineProperties","configurable","enumerable","writable","parsed","parse","relative","base","resolve","urlObject","target","spread","key","startsWith","port","Number","regex","lastValue","header","undefined","String","trim","message","baseClass","CustomError","properties","constructor","subdomain","domain","dot","endsWith","module"],"mappings":"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","sourcesContent":["var url = require(\"url\");\nvar URL = url.URL;\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar Writable = require(\"stream\").Writable;\nvar assert = require(\"assert\");\nvar debug = require(\"./debug\");\n\n// Preventive platform detection\n// istanbul ignore next\n(function detectUnsupportedEnvironment() {\n  var looksLikeNode = typeof process !== \"undefined\";\n  var looksLikeBrowser = typeof window !== \"undefined\" && typeof document !== \"undefined\";\n  var looksLikeV8 = isFunction(Error.captureStackTrace);\n  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {\n    console.warn(\"The follow-redirects package should be excluded from browser builds.\");\n  }\n}());\n\n// Whether to use the native URL object or the legacy url module\nvar useNativeURL = false;\ntry {\n  assert(new URL(\"\"));\n}\ncatch (error) {\n  useNativeURL = error.code === \"ERR_INVALID_URL\";\n}\n\n// URL fields to preserve in copy operations\nvar preservedUrlFields = [\n  \"auth\",\n  \"host\",\n  \"hostname\",\n  \"href\",\n  \"path\",\n  \"pathname\",\n  \"port\",\n  \"protocol\",\n  \"query\",\n  \"search\",\n  \"hash\",\n];\n\n// Create handlers that pass events from native requests\nvar events = [\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"];\nvar eventHandlers = Object.create(null);\nevents.forEach(function (event) {\n  eventHandlers[event] = function (arg1, arg2, arg3) {\n    this._redirectable.emit(event, arg1, arg2, arg3);\n  };\n});\n\n// Error types with codes\nvar InvalidUrlError = createErrorType(\n  \"ERR_INVALID_URL\",\n  \"Invalid URL\",\n  TypeError\n);\nvar RedirectionError = createErrorType(\n  \"ERR_FR_REDIRECTION_FAILURE\",\n  \"Redirected request failed\"\n);\nvar TooManyRedirectsError = createErrorType(\n  \"ERR_FR_TOO_MANY_REDIRECTS\",\n  \"Maximum number of redirects exceeded\",\n  RedirectionError\n);\nvar MaxBodyLengthExceededError = createErrorType(\n  \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\",\n  \"Request body larger than maxBodyLength limit\"\n);\nvar WriteAfterEndError = createErrorType(\n  \"ERR_STREAM_WRITE_AFTER_END\",\n  \"write after end\"\n);\n\n// istanbul ignore next\nvar destroy = Writable.prototype.destroy || noop;\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  this._sanitizeOptions(options);\n  this._options = options;\n  this._ended = false;\n  this._ending = false;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    try {\n      self._processResponse(response);\n    }\n    catch (cause) {\n      self.emit(\"error\", cause instanceof RedirectionError ?\n        cause : new RedirectionError({ cause: cause }));\n    }\n  };\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\nRedirectableRequest.prototype.abort = function () {\n  destroyRequest(this._currentRequest);\n  this._currentRequest.abort();\n  this.emit(\"abort\");\n};\n\nRedirectableRequest.prototype.destroy = function (error) {\n  destroyRequest(this._currentRequest, error);\n  destroy.call(this, error);\n  return this;\n};\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Writing is not allowed if end has been called\n  if (this._ending) {\n    throw new WriteAfterEndError();\n  }\n\n  // Validate input and shift parameters if necessary\n  if (!isString(data) && !isBuffer(data)) {\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\n  }\n  if (isFunction(encoding)) {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n  // Only write when we don't exceed the maximum body length\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new MaxBodyLengthExceededError());\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (isFunction(data)) {\n    callback = data;\n    data = encoding = null;\n  }\n  else if (isFunction(encoding)) {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Write data if needed and end\n  if (!data) {\n    this._ended = this._ending = true;\n    this._currentRequest.end(null, null, callback);\n  }\n  else {\n    var self = this;\n    var currentRequest = this._currentRequest;\n    this.write(data, encoding, function () {\n      self._ended = true;\n      currentRequest.end(null, null, callback);\n    });\n    this._ending = true;\n  }\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Global timeout for all underlying requests\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\n  var self = this;\n\n  // Destroys the socket on timeout\n  function destroyOnTimeout(socket) {\n    socket.setTimeout(msecs);\n    socket.removeListener(\"timeout\", socket.destroy);\n    socket.addListener(\"timeout\", socket.destroy);\n  }\n\n  // Sets up a timer to trigger a timeout event\n  function startTimer(socket) {\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n    }\n    self._timeout = setTimeout(function () {\n      self.emit(\"timeout\");\n      clearTimer();\n    }, msecs);\n    destroyOnTimeout(socket);\n  }\n\n  // Stops a timeout from triggering\n  function clearTimer() {\n    // Clear the timeout\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n      self._timeout = null;\n    }\n\n    // Clean up all attached listeners\n    self.removeListener(\"abort\", clearTimer);\n    self.removeListener(\"error\", clearTimer);\n    self.removeListener(\"response\", clearTimer);\n    self.removeListener(\"close\", clearTimer);\n    if (callback) {\n      self.removeListener(\"timeout\", callback);\n    }\n    if (!self.socket) {\n      self._currentRequest.removeListener(\"socket\", startTimer);\n    }\n  }\n\n  // Attach callback if passed\n  if (callback) {\n    this.on(\"timeout\", callback);\n  }\n\n  // Start the timer if or when the socket is opened\n  if (this.socket) {\n    startTimer(this.socket);\n  }\n  else {\n    this._currentRequest.once(\"socket\", startTimer);\n  }\n\n  // Clean up on events\n  this.on(\"socket\", destroyOnTimeout);\n  this.on(\"abort\", clearTimer);\n  this.on(\"error\", clearTimer);\n  this.on(\"response\", clearTimer);\n  this.on(\"close\", clearTimer);\n\n  return this;\n};\n\n// Proxy all other public ClientRequest methods\n[\n  \"flushHeaders\", \"getHeader\",\n  \"setNoDelay\", \"setSocketKeepAlive\",\n].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () { return this._currentRequest[property]; },\n  });\n});\n\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\n  // Ensure headers are always present\n  if (!options.headers) {\n    options.headers = {};\n  }\n\n  // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n    delete options.host;\n  }\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    }\n    else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n};\n\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n  if (!nativeProtocol) {\n    throw new TypeError(\"Unsupported protocol \" + protocol);\n  }\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.slice(0, -1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request and set up its event handlers\n  var request = this._currentRequest =\n        nativeProtocol.request(this._options, this._onNativeResponse);\n  request._redirectable = this;\n  for (var event of events) {\n    request.on(event, eventHandlers[event]);\n  }\n\n  // RFC7230§5.3.1: When making a request directly to an origin server, […]\n  // a client MUST send only the absolute path […] as the request-target.\n  this._currentUrl = /^\\//.test(this._options.path) ?\n    url.format(this._options) :\n    // When making a request to a proxy, […]\n    // a client MUST send the target URI in absolute-form […].\n    this._options.path;\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end\n    var i = 0;\n    var self = this;\n    var buffers = this._requestBodyBuffers;\n    (function writeNext(error) {\n      // Only write if this request has not been redirected yet\n      // istanbul ignore else\n      if (request === self._currentRequest) {\n        // Report any write errors\n        // istanbul ignore if\n        if (error) {\n          self.emit(\"error\", error);\n        }\n        // Write the next buffer if there are still left\n        else if (i < buffers.length) {\n          var buffer = buffers[i++];\n          // istanbul ignore else\n          if (!request.finished) {\n            request.write(buffer.data, buffer.encoding, writeNext);\n          }\n        }\n        // End the request if `end` has been called on us\n        else if (self._ended) {\n          request.end();\n        }\n      }\n    }());\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  var statusCode = response.statusCode;\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: statusCode,\n    });\n  }\n\n  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n\n  // If the response is not a redirect; return it as-is\n  var location = response.headers.location;\n  if (!location || this._options.followRedirects === false ||\n      statusCode < 300 || statusCode >= 400) {\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n    return;\n  }\n\n  // The response is a redirect, so abort the current request\n  destroyRequest(this._currentRequest);\n  // Discard the remainder of the response to avoid waiting for data\n  response.destroy();\n\n  // RFC7231§6.4: A client SHOULD detect and intervene\n  // in cyclical redirections (i.e., \"infinite\" redirection loops).\n  if (++this._redirectCount > this._options.maxRedirects) {\n    throw new TooManyRedirectsError();\n  }\n\n  // Store the request headers if applicable\n  var requestHeaders;\n  var beforeRedirect = this._options.beforeRedirect;\n  if (beforeRedirect) {\n    requestHeaders = Object.assign({\n      // The Host header was set by nativeProtocol.request\n      Host: response.req.getHeader(\"host\"),\n    }, this._options.headers);\n  }\n\n  // RFC7231§6.4: Automatic redirection needs to done with\n  // care for methods not known to be safe, […]\n  // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change\n  // the request method from POST to GET for the subsequent request.\n  var method = this._options.method;\n  if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" ||\n      // RFC7231§6.4.4: The 303 (See Other) status code indicates that\n      // the server is redirecting the user agent to a different resource […]\n      // A user agent can perform a retrieval request targeting that URI\n      // (a GET or HEAD request if using HTTP) […]\n      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {\n    this._options.method = \"GET\";\n    // Drop a possible entity and headers related to it\n    this._requestBodyBuffers = [];\n    removeMatchingHeaders(/^content-/i, this._options.headers);\n  }\n\n  // Drop the Host header, as the redirect might lead to a different host\n  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);\n\n  // If the redirect is relative, carry over the host of the last request\n  var currentUrlParts = parseUrl(this._currentUrl);\n  var currentHost = currentHostHeader || currentUrlParts.host;\n  var currentUrl = /^\\w+:/.test(location) ? this._currentUrl :\n    url.format(Object.assign(currentUrlParts, { host: currentHost }));\n\n  // Create the redirected request\n  var redirectUrl = resolveUrl(location, currentUrl);\n  debug(\"redirecting to\", redirectUrl.href);\n  this._isRedirect = true;\n  spreadUrlObject(redirectUrl, this._options);\n\n  // Drop confidential headers when redirecting to a less secure protocol\n  // or to a different domain that is not a superdomain\n  if (redirectUrl.protocol !== currentUrlParts.protocol &&\n     redirectUrl.protocol !== \"https:\" ||\n     redirectUrl.host !== currentHost &&\n     !isSubdomain(redirectUrl.host, currentHost)) {\n    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);\n  }\n\n  // Evaluate the beforeRedirect callback\n  if (isFunction(beforeRedirect)) {\n    var responseDetails = {\n      headers: response.headers,\n      statusCode: statusCode,\n    };\n    var requestDetails = {\n      url: currentUrl,\n      method: method,\n      headers: requestHeaders,\n    };\n    beforeRedirect(this._options, responseDetails, requestDetails);\n    this._sanitizeOptions(this._options);\n  }\n\n  // Perform the redirected request\n  this._performRequest();\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024,\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    function request(input, options, callback) {\n      // Parse parameters, ensuring that input is an object\n      if (isURL(input)) {\n        input = spreadUrlObject(input);\n      }\n      else if (isString(input)) {\n        input = spreadUrlObject(parseUrl(input));\n      }\n      else {\n        callback = options;\n        options = validateUrl(input);\n        input = { protocol: protocol };\n      }\n      if (isFunction(options)) {\n        callback = options;\n        options = null;\n      }\n\n      // Set defaults\n      options = Object.assign({\n        maxRedirects: exports.maxRedirects,\n        maxBodyLength: exports.maxBodyLength,\n      }, input, options);\n      options.nativeProtocols = nativeProtocols;\n      if (!isString(options.host) && !isString(options.hostname)) {\n        options.hostname = \"::1\";\n      }\n\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    }\n\n    // Executes a GET request, following redirects\n    function get(input, options, callback) {\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\n      wrappedRequest.end();\n      return wrappedRequest;\n    }\n\n    // Expose the properties on the wrapped protocol\n    Object.defineProperties(wrappedProtocol, {\n      request: { value: request, configurable: true, enumerable: true, writable: true },\n      get: { value: get, configurable: true, enumerable: true, writable: true },\n    });\n  });\n  return exports;\n}\n\nfunction noop() { /* empty */ }\n\nfunction parseUrl(input) {\n  var parsed;\n  // istanbul ignore else\n  if (useNativeURL) {\n    parsed = new URL(input);\n  }\n  else {\n    // Ensure the URL is valid and absolute\n    parsed = validateUrl(url.parse(input));\n    if (!isString(parsed.protocol)) {\n      throw new InvalidUrlError({ input });\n    }\n  }\n  return parsed;\n}\n\nfunction resolveUrl(relative, base) {\n  // istanbul ignore next\n  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));\n}\n\nfunction validateUrl(input) {\n  if (/^\\[/.test(input.hostname) && !/^\\[[:0-9a-f]+\\]$/i.test(input.hostname)) {\n    throw new InvalidUrlError({ input: input.href || input });\n  }\n  if (/^\\[/.test(input.host) && !/^\\[[:0-9a-f]+\\](:\\d+)?$/i.test(input.host)) {\n    throw new InvalidUrlError({ input: input.href || input });\n  }\n  return input;\n}\n\nfunction spreadUrlObject(urlObject, target) {\n  var spread = target || {};\n  for (var key of preservedUrlFields) {\n    spread[key] = urlObject[key];\n  }\n\n  // Fix IPv6 hostname\n  if (spread.hostname.startsWith(\"[\")) {\n    spread.hostname = spread.hostname.slice(1, -1);\n  }\n  // Ensure port is a number\n  if (spread.port !== \"\") {\n    spread.port = Number(spread.port);\n  }\n  // Concatenate path\n  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;\n\n  return spread;\n}\n\nfunction removeMatchingHeaders(regex, headers) {\n  var lastValue;\n  for (var header in headers) {\n    if (regex.test(header)) {\n      lastValue = headers[header];\n      delete headers[header];\n    }\n  }\n  return (lastValue === null || typeof lastValue === \"undefined\") ?\n    undefined : String(lastValue).trim();\n}\n\nfunction createErrorType(code, message, baseClass) {\n  // Create constructor\n  function CustomError(properties) {\n    // istanbul ignore else\n    if (isFunction(Error.captureStackTrace)) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n    Object.assign(this, properties || {});\n    this.code = code;\n    this.message = this.cause ? message + \": \" + this.cause.message : message;\n  }\n\n  // Attach constructor and set default properties\n  CustomError.prototype = new (baseClass || Error)();\n  Object.defineProperties(CustomError.prototype, {\n    constructor: {\n      value: CustomError,\n      enumerable: false,\n    },\n    name: {\n      value: \"Error [\" + code + \"]\",\n      enumerable: false,\n    },\n  });\n  return CustomError;\n}\n\nfunction destroyRequest(request, error) {\n  for (var event of events) {\n    request.removeListener(event, eventHandlers[event]);\n  }\n  request.on(\"error\", noop);\n  request.destroy(error);\n}\n\nfunction isSubdomain(subdomain, domain) {\n  assert(isString(subdomain) && isString(domain));\n  var dot = subdomain.length - domain.length - 1;\n  return dot > 0 && subdomain[dot] === \".\" && subdomain.endsWith(domain);\n}\n\nfunction isString(value) {\n  return typeof value === \"string\" || value instanceof String;\n}\n\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\n\nfunction isBuffer(value) {\n  return typeof value === \"object\" && (\"length\" in value);\n}\n\nfunction isURL(value) {\n  return URL && value instanceof URL;\n}\n\n// Exports\nmodule.exports = wrap({ http: http, https: https });\nmodule.exports.wrap = wrap;\n"]},"metadata":{},"sourceType":"script"}